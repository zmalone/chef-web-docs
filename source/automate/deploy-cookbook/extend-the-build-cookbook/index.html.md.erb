---
title: 'Extend the build cookbook'
order: 5
keywords: TODO
layout: lesson
sections: []
next: {heading: 'Conclusion and next steps', partial: conclusion}
time_to_complete: 30 minutes
show_disqus: false
meta_tags: [{name: "ROBOTS", content: "NOINDEX, NOFOLLOW"}]
---
In the previous part, you manually verified that the Customers application was running in each of the Acceptance, Union, Rehearsal, and Delivered environments. In practice, it's common to have some manual verification process to validate that your application or service is up and functioning. For example, if you're deploying a web application, someone will typically test out a new feature manually on a pre-production server before releasing the feature to production.

However, you can also write _smoke tests_ to quickly validate that the application or service is running and functional. If the smoke tests fail, you know that the application or service has failed.

Remember that Chef Automate works with almost any kind of application or infrastructure project, and that the `delivery-truck` cookbook helps perform many common tasks that are needed to deliver Chef cookbooks. However, because a cookbook can configure any part of the system, `delivery-truck` cannot provide a default implementation for some phases, such as the smoke phase.

In this part, you implement the smoke phase to run cURL and verify that the web server responds with a 200 (OK) response. The smoke phase runs in the Acceptance, Union, Rehearsal, and Delivered stages.

<img src="/assets/images/delivery/delivery_full_workflow_smoke.svg" style="width: 100%; box-shadow: none;" />

[START_BOX]

## 1. Create a feature branch

First, checkout the `master` branch and pull down the latest changes from Chef Automate's Git server.

```ps
# C:\Users\Administrator\cookbooks\awesome_customers_delivery
$ git checkout master
Switched to branch 'master'
Your branch is up-to-date with 'delivery/master'.
$ git pull --prune
From ssh://mammalia@delivery.chordata.biz:8989/mammalia/diprotodontia/awesome_customers_delivery
 x [deleted]         (none)     -> delivery/_for/master/visualize_data
remote: Counting objects: 1, done.
remote: Total 1 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (1/1), done.
   52073fb..ab75e1f  master     -> delivery/master
Updating 52073fb..ab75e1f
Fast-forward
 attributes/default.rb         |   2 +-
 files/default/customer.php    |  33 +++++++-
 files/default/index.php       |  51 +++++++------
 files/default/styles.css      |  37 +++++++++
 files/default/vis.js          | 171 ++++++++++++++++++++++++++++++++++++++++++
 files/default/world-110m.json |   1 +
 metadata.rb                   |   2 +-
 7 files changed, 268 insertions(+), 29 deletions(-)
 create mode 100644 files/default/styles.css
 create mode 100644 files/default/vis.js
 create mode 100644 files/default/world-110m.json
```

Next, create a new branch named `smoke`.

```ps
# C:\Users\Administrator\cookbooks\awesome_customers_delivery
$ git checkout -b smoke
Switched to a new branch 'smoke'
```

[END_BOX]

[START_BOX]

## 2. Write the recipe for the smoke phase

Smoke tests are meant to be fast so that you quickly discover if the application or service is not working. For the Customers web application, we'll simply run cURL to verify that the server responds with a 200 (OK) HTTP status code.

Write your `smoke` recipe, <br><%fp 'C:\Users\Administrator\cookbooks\awesome_customers_delivery\\\\.delivery\build-cookbook\recipes\smoke.rb' %>,  like this.

```ruby-Win32
# C:\Users\Administrator\cookbooks\awesome_customers_delivery\.delivery\build-cookbook\recipes\smoke.rb
include_recipe 'delivery-truck::smoke'

# Create a search query that matches the current environment.
search_query = "chef_environment:#{delivery_environment}"

# Run the query.
nodes = delivery_chef_server_search(:node, search_query)

# cURL the IP address of each result and verify a 200 (OK) response.
nodes.each do |node|
  address = node['ipaddress']
  execute "cURL #{address} and verify 200 response" do
    command "curl -IL #{address} | grep '^HTTP/1\.1 200 OK'"
  end
end
```

This code performs a similar query as the one in the deploy phase. For each node in the environment (we expect only one), we use the [execute](https://docs.chef.io/resource_execute.html) resource to run `curl` with the `-IL` flag (fetch HTTP reader only and follow any redirects) and search for the expected response code.

If the cURL command fails, the details are shown in the output and the pipeline moves to a failed state. You may then need to work with your team to examine and fix the failure. The fix may require you to push a new change through the pipeline, which is a completely acceptable thing to do.

[END_BOX]

[START_BOX]

## 3. Submit, review, and approve the change

Let's try out our smoke test. Follow the same steps as before to submit your change and trigger the pipeline.

```ps
# C:\Users\Administrator\cookbooks\awesome_customers_delivery
$ git status
On branch smoke
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   .delivery/build-cookbook/recipes/smoke.rb

no changes added to commit (use "git add" and/or "git commit -a")
$ git add .\.delivery\build-cookbook\recipes\smoke.rb
$ git commit -m "Add smoke test"
[smoke d1ea7c5] Add smoke test
 1 file changed, 14 insertions(+)
$ delivery review
Chef Delivery
Loading configuration from C:\Users\Administrator\awesome_customers_delivery
Review for change smoke targeted for pipeline master
Created new patchset
https://delivery.chordata.biz/e/mammalia/#/organizations/diprotodontia/projects/awesome_customers_delivery/changes/a7d54
ea4-d41a-4895-ad02-e6f5b6c3c437
```

Trace the change's progress through the pipeline to the Acceptance stage.

1. Review the changes in the web interface. Click **Approve** when all tests pass.
1. Watch the change progress through the Build and Acceptance stages.

Watch as the smoke test runs and passes.

![](automate/wf-smoke-log.png)

After Acceptance succeeds, press the **Deliver** button, then press **Confirm**.

![](automate/wf-smoke-press-deliver.png)

This moves the change through the Union, Rehearsal, and Delivered stages.

<img src="/assets/images/automate/wf-smoke-union.png" style="max-width: 100%;" />

Nice job! With smoke testing in place, you have increased confidence in your changes, which enables you to perform less manual testing. For instance, you might continue to manually verify new features in the Acceptance and Delivered environments, but you might not necessarily need to verify each change in Union and Rehearsal.

As your project evolves, you can implement additional phases such as quality, security, and functional to build further confidence in your changes and further reduce the need to manually verify new features.

Remember to integrate the latest changes into your local `master` branch before creating a new feature branch.

```ps
# C:\Users\Administrator\cookbooks\awesome_customers_delivery
$ git checkout master
Switched to branch 'master'
Your branch is up-to-date with 'delivery/master'.
$ git pull --prune
From ssh://mammalia@delivery.chordata.biz:8989/mammalia/diprotodontia/awesome_customers_delivery
 x [deleted]         (none)     -> delivery/_for/master/smoke
remote: Counting objects: 1, done.
remote: Total 1 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (1/1), done.
   ab75e1f..b1472ab  master     -> delivery/master
Updating ab75e1f..b1472ab
Fast-forward
 .delivery/build-cookbook/recipes/smoke.rb | 14 ++++++++++++++
 1 file changed, 14 insertions(+)
```

[END_BOX]

[START_BOX]

## Skipped phases

There are many other types of tests you can run that we haven't discussed here. For example, the Build stage has a quality phase. You can use this phase to run additional test suites and code analysis tools that are too time consuming to run in the Verify stage. You don't want to run these tests until you know the code is approved.

In many organizations, a change must pass a suite of security tests before it can be deployed. The Build stage is a good place to run these tests, as well.

Functional tests can run in the Acceptance, Union, Rehearsal and Delivered stages. These tests should give you confidence that the system is meeting its business requirements.

Even when a phase does no work, it still takes time for its recipe to run. You can omit phases entirely from the pipeline by including them in the `skip_phases` portion of your project's configuration file.

Here's an example that skips the phases we haven't discussed here &ndash; quality, security, and functional.

```ruby-Win32
# .delivery\config.json
{
  "version": "2",
  "build_cookbook": {
    "name": "build-cookbook",
    "path": ".delivery/build-cookbook"
  },
  "skip_phases": ["quality", "security", "functional"],
  "build_nodes": {},
  "dependencies": []
}
```

<img src="/assets/images/delivery/delivery_full_workflow_skipped.svg" style="width: 100%; box-shadow: none;" />

Your changes will move more quickly through the pipeline because those phases are skipped.

![](delivery/skip-phases.png)

[END_BOX]
