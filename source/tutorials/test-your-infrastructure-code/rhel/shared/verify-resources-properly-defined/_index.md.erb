[HEADLINE] ChefSpec simulates the execution of your resources, giving you an even faster feedback loop as you create and refine your recipes.

In the previous lesson, you wrote InSpec tests that automatically verified that your basic web server cookbook configures Apache as you expect. Although automated testing is faster than manual testing, it can still take some time for the instance to come up, run `chef-client`, and run the tests.

You'll want to verify your work on a virtual instance before you run your cookbook in production, but as you develop your cookbook, you can use [ChefSpec](https://docs.chef.io/chefspec.html) to speed up the feedback cycle even more. ChefSpec _simulates_ the execution of your resources in memory, and does not involve the creation of a virtual instance. It's the fastest way to test your resources and is a great way to validate the correctness of your work, even before you set up a virtual instance to test on.

ChefSpec testing is also helpful when you use [continuous delivery](https://en.wikipedia.org/wiki/Continuous_delivery) (CD) systems such as [Chef Automate](https://www.chef.io/automate/) because ChefSpec enables you to verify your code without the need to bring up additional test systems.

ChefSpec provides a kind of _unit_ testing, where you verify that a single component, such as a Chef resource, functions correctly. Unlike integration testing, unit testing does not focus on how multiple components work together.

ChefSpec testing is most useful when a component's behavior varies based on the environment or other variable input. For example, say you define this `package` resource to install the `vim` text editor.

```ruby
# default.rb
package 'vim' do
  action :install
end
```

You don't need to write a unit test here because this `package` resource can do only one thing &ndash; install the `vim` package if it's not already installed. However, say your `package` resource reads from a node attribute to determine which text editor to install.

```ruby
# default.rb
package node['text_editor'] do
  action :install
end
```

In this case, you might want to validate that when the `node['text_editor']` attribute is set, that the appropriate text editor would be installed.

In this lesson, you'll modify the `webserver_test` cookbook to work on both CentOS and Ubuntu. The way Apache is installed and managed differs slightly on both platforms.

Recall that your `webserver_test` cookbook's default recipe looks like this.

<% code_snippet(page: current_page.previous_page, path: 'make-remaining-tests-pass/default-2-rhel') %>

You know that this configuration works on CentOS. But on Ubuntu, both the Apache package and service name are `apache2`, not `httpd`.

For this part, let's revise the requirements for the web server configuration to focus on these two criteria:

<% unstyled_list do %>
  <% icon_list_item('square-o') do %>
    On CentOS, install the <code>httpd</code> package and enable and start the <code>httpd</code> service.
  <% end %>
  <% icon_list_item('square-o') do %>
    On Ubuntu, install the <code>apache2</code> package and enable and start the <code>apache2</code> service.
  <% end %>
<% end %>

You need to write code to ensure that your cookbook performs the correct steps in both environments. Here you'll write ChefSpec tests that verify that the code is defined correctly for both platforms &ndash; without the need to run it on a local instance.

You'll start by writing ChefSpec tests that verify your existing CentOS web server configuration. Then you'll add additional tests for the same configuration on Ubuntu. After seeing the tests fail, you'll go back to your recipe and add just enough code to make the tests pass.

Here's a 60-minute webcast that discusses ChefSpec in greater depth and shows working examples. You can watch the video before or after you complete this tutorial.

<script type="text/javascript" src="https://www.brighttalk.com/clients/js/embed/embed.js"></script> <object class="BrightTALKEmbed" width="705" height="660">     <param name="player" value="channel_player"/>     <param name="domain" value="https://www.brighttalk.com"/>     <param name="channelid" value="11349"/>     <param name="communicationid" value="194483"/>     <param name="autoStart" value="false"/>     <param name="theme" value=""/> </object>

[START_BOX]

## 1. Write ChefSpec tests that verify the current web server configuration

Let's begin by writing ChefSpec tests that verify the CentOS web server configuration.

For ChefSpec, tests go in your cookbook's `spec` directory. The `chef generate cookbook` command creates this directory for you.

<% command_snippet(page: current_page, path: 'write-chefspec-tests/tree-spec-dir') %>

You typically define one test, or spec, file for each recipe. So <code class="file-path">default\_spec.rb</code> maps to the default recipe, <code class="file-path">default.rb</code>. If you had a second recipe, say <code class="file-path">firewall.rb</code>, then you would have a spec named <code class="file-path">firewall\_spec.rb</code>.

The default spec that's generated looks like this.

<% code_snippet(page: current_page, path: 'write-chefspec-tests/default_spec-0') %>

The `describe` blocks tells ChefSpec to run the `webserver_test::default` recipe in memory. The `let` block simulates the `chef-client` run. It also defines the `chef_run` variable, which is used in each test to validate the result.

`ChefSpec::ServerRunner` specifies how to run `chef-client` in memory. It's a common option because it also simulates an in-memory Chef server, allowing you to access [data bags](https://docs.chef.io/data_bags.html) and other features.

ChefSpec code resembles InSpec because both are based on the [RSpec](http://rspec.info) testing framework. RSpec [provides two ways to express tests](http://rspec.info/blog/2012/06/rspecs-new-expectation-syntax/). In the previous lesson, you used what's commonly called RSpec's _should_ syntax. In this part, you'll use RSpec's _expectation_ syntax.

Modify your copy of <% fp 'default_spec.rb' %> like this.

<% code_snippet(page: current_page, path: 'write-chefspec-tests/default_spec-1') %>

Like InSpec, ChefSpec tests resemble natural language. For example, this test expects the Chef run to install the `httpd` package.

```ruby
# ~/learn-chef/cookbooks/webserver_test/spec/unit/recipes/default_spec.rb
it 'installs httpd' do
  expect(chef_run).to install_package 'httpd'
end
```

The `install_package` part is known as a _matcher_. The [ChefSpec documentation](http://www.rubydoc.info/github/sethvargo/chefspec) lists the matchers that are available for your tests. For example, [ServiceMatchers](http://www.rubydoc.info/github/sethvargo/chefspec/ChefSpec/API/ServiceMatchers) describes the `enable_service` and `start_service` matchers.

[COMMENT] A great way to learn how to write good tests is by example. The ChefSpec project contains [example tests](https://github.com/sethvargo/chefspec/tree/master/examples) for many common Chef resource types.

Now let's run your tests. In the previous lesson, you ran your InSpec tests through Test Kitchen. To run ChefSpec tests, you run a program called [rspec](https://relishapp.com/rspec/rspec-core/docs/command-line).

First, make sure you're in the <% fp 'webserver_test' %> directory.

<% command_snippet(page: current_page, path: 'write-chefspec-tests/cd-webserver_test-2', features: :stdin) %>

Now run this command to run your tests. The [chef exec](https://docs.chef.io/ctl_chef.html#chef-exec) part ensures that `rpsec` is run using Chef's domain-specific language. The `--color` part is optional, but can help you visually distinguish passing from failing tests.

<% command_snippet(page: current_page, path: 'write-chefspec-tests/chef-exec-rspec-1') %>

[COMMENT] If you had multiple ChefSpec files, you would use `chef exec rspec --color spec/unit/recipes/*.rb` or `chef exec rspec --color` to run them all.

You see that no failures were reported. You've successfully validated the first requirement, which is to configure Apache on CentOS.

<% unstyled_list do %>
  <% icon_list_item('check-square-o') do %>
    On CentOS, install the <code>httpd</code> package and enable and start the <code>httpd</code> service.
  <% end %>
  <% icon_list_item('square-o') do %>
    On Ubuntu, install the <code>apache2</code> package and enable and start the <code>apache2</code> service.
  <% end %>
<% end %>

[COMMENT] Remember, ChefSpec only simluates the execution of your resources; it doesn't run the code on a real instance. Unlike the InSpec tests, we can't verify things like whether port 80 would be open or whether `curl localhost` would succeed because ChefSpec does not have that information. ChefSpec tests only what's expressed directly in your code.

<% accordion('more-about-expect', 'A closer look at the expect method') do %>

<%= partial '/tutorials/test-your-infrastructure-code/shared/exception_syntax' %>

<% end %>
&nbsp;

[END_BOX]

[START_BOX]

## 2. Define the CentOS context

The next step is to write tests for the Ubuntu web server configuration. The Ubuntu tests will resemble the CentOS tests, but will use the `apache2` package and service name instead of `httpd`.

To keep the tests organized by platform, you'll use a _context_ block. You define one context for CentOS and one for Ubuntu. The following example illustrates this structure.

<% code_snippet(page: current_page, path: 'define-the-context/default_spec-2-structure') %>

Before we write tests for Ubuntu, let's first add a context for CentOS. Modify your copy of <% fp 'default_spec.rb' %> like this.

<% code_snippet(page: current_page, path: 'define-the-context/default_spec-2') %>

Notice two differences in this example.

* The tests are grouped in a `context` block. A `context` block groups related tests.
* `ServerRunner` is created by specifying the platform and version. ChefSpec uses these values to construct [automatic node attributes](https://docs.chef.io/ohai.html#automatic-attributes), for example `node['platform']` and `node['platform_version']`.

Recall Chef server holds information about your nodes, called _node attributes_, and that your node can access these attributes when `chef-client` runs.

Because ChefSpec simulates your recipes, but does not run them, it needs a way to also simulate access to node attributes. [Ohai](https://docs.chef.io/ohai.html) is the tool that normally detects node attributes and provides them to `chef-client` at the start of every run. To simulate the process, ChefSpec uses [fauxhai](https://github.com/customink/fauxhai). Fauxhai provides _mock_, or test, data for [common platforms](https://github.com/customink/fauxhai/tree/master/lib/fauxhai/platforms).

For CentOS, to know which value to specify for `version`, you can run `kitchen create` to create a test instance. Then, run this [kitchen exec](https://docs.chef.io/ctl_kitchen.html#kitchen-exec) command to execute `cat /etc/centos-release` on your instance over SSH.

<% command_snippet(page: current_page, path: 'define-the-context/kitchen-exec-centos-release') %>

Fauxhai provides node attributes for [CentOS 7.2.1511](https://github.com/customink/fauxhai/blob/master/lib/fauxhai/platforms/centos/7.2.1511.json). Although these values might not exactly match your configuration, think of them as test data that you can use to verify the correctness of your resources.

[COMMENT] You can [override](https://github.com/customink/fauxhai#overriding) node attributes in your test code. You can also use [real server data](https://github.com/customink/fauxhai#fetching) or [provide your own attributes file](https://github.com/customink/fauxhai#fixturing).

Run the tests to verify that they continue to pass.

<% command_snippet(page: current_page, path: 'define-the-context/chef-exec-rspec-2') %>

The tests still pass.

Next, you'll add a second `context` block that holds the tests for Ubuntu.

[END_BOX]

[START_BOX]

## 3. Write ChefSpec tests for the Ubuntu web server configuration

Now let's repeat the pattern we used with CentOS for the Ubuntu ChefSpec tests.

Begin by adding tests to <% fp 'spec/unit/recipes/default_spec.rb' %> that validate that the proper package and service names are used on both CentOS and Ubuntu. The entire file looks like this.

<% code_snippet(page: current_page, path: 'write-chefspec-tests-for-ubuntu/default_spec-3') %>

Now run the ChefSpec tests, like this.

<% command_snippet(page: current_page, path: 'write-chefspec-tests-for-ubuntu/chef-exec-rspec-3') %>

As you might expect, the CentOS tests pass, but the Ubuntu tests fail.

<% command_snippet(page: current_page, path: 'write-chefspec-tests-for-ubuntu/chef-exec-rspec-4', features: :stdout) %>

The Ubuntu tests fail because the default recipe configures `httpd` unconditionally on all platforms. Your ChefSpec tests expect the recipe to configure `apache2` when run on Ubuntu.

As with InSpec tests, having failing ChefSpec tests shows what functionality is missing and gives you clear goals to work towards.

[END_BOX]

[START_BOX]

## 4. Revise the webserver_test cookbook to support Ubuntu

Let's revise the `webserver_test` cookbook to run on both CentOS and Ubuntu. To do so, we'll define variables that hold the name of the package and service to manage. We'll use the built-in `node['platform']` node attribute to set these variables to their appropriate values.

Modify your `webserver_test` cookbook's default recipe like this.

<% code_snippet(page: current_page, path: 'revise-cookbook-for-ubuntu/default-3-rhel') %>

This code uses a [case](http://ruby-doc.org/docs/keywords/1.9/Object.html#method-i-case) statement to match the platform name to the name of the package and the service. The `package_name` and `service_name` variables are later used in the `package` and `service` resources.

[COMMENT] For learning purposes, we're building a basic multi-platform cookbook from scratch. In practice, you might use the [httpd](https://supermarket.chef.io/cookbooks/httpd) cookbook from Chef Supermarket, which already supports multiple platforms.

Now let's verify whether our updated cookbook passes our ChefSpec tests. We want to see whether the tests for Ubuntu now pass and also verify that the tests for CentOS continue to pass.

<% command_snippet(page: current_page, path: 'revise-cookbook-for-ubuntu/chef-exec-rspec-5') %>

Great! All tests pass. In this example, the entire run took about 2 seconds to complete. This process is much faster than applying the configuration on real CentOS and Ubuntu instances, and is a great way to quickly validate that the resources are properly defined.

[COMMENT] Many users start with InSpec first because it's easy to understand. As you gain familiarity with the various kinds of testing, you might actually write your ChefSpec tests first because ChefSpec tests typically run more quickly, and can help identify potential issues earlier in the process.

[END_BOX]

[START_BOX]

## 5. Refactor the tests to reduce repeated code

Notice that the tests for Ubuntu and CentOS are similar. Each set of tests validates the same concerns. The only difference is the names used for the package and the service.

<% code_snippet(page: current_page, path: 'write-chefspec-tests-for-ubuntu/default_spec-3') %>

If you wanted to add a new test or modify an existing one, you would need to repeat that code for each platform you support. As you include additional platforms, the process can become tedious and error-prone.

Although not required, you might refactor some tests to reduce the amount of repeated code. One way you might refactor these tests is to use a [shared example](http://modocache.io/shared-examples-in-rspec).

A shared example enables you to define reusable test code. Think of a shared example as a template that contains placeholders that are filled in by other tests.

To try it, replace the contents of <% fp 'default_spec.rb' %> with this code.

<% code_snippet(page: current_page, path: 'refactor-reduce-repeated-code/default_spec-4') %>

The `shared_examples` block takes as its arguments the platform name and version, as well as the Apache package and service names. These values are filled in when the tests run.

The `describe` block at the end of this example defines the test data. The `include_examples` method calls the `webserver_test` shared examples two times, once for Ubuntu and once for CentOS.

[COMMENT] `*platform_data` is an example of a [splat](http://www.justinweiss.com/articles/fun-with-keyword-arguments/). A splat extracts the values of an array so they can be used as individual arguments to the `webserver_test` shared examples.

Run ChefSpec to verify that the refactored tests continue to pass.

<% command_snippet(page: current_page, path: 'refactor-reduce-repeated-code/chef-exec-rspec-6') %>

[GITHUB] [Get the code for this lesson](https://github.com/learn-chef/webserver_test/tree/lesson2_rhel) on GitHub.

[END_BOX]

<% next_page(current_page) do %>

After you've verified that your cookbook does what you intend, it's a recommended practice to run _lint_ tools to ensure that your code meets accepted code standards and avoids common defects. In the next lesson, you'll learn how.

<% end %>
